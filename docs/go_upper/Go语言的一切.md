---
siderbar: 1
---

# go语言的一切

## 起源

2007 年 9 月 20 日，Rob Pike、Robert Griesemer 和 Ken Thompson 在谷歌讨论设计新语言，这就是 Go 语言的起点。他们当时用 C++，但编译时间太长，而且并发处理不够好。所以他们想设计一个更高效、更简单的语言。另外，其他资料比如《代码的未来》和文章也提到，谷歌内部对 C/C++ 不满，需要更好的系统编程语言，尤其是处理并发问题。

接下来，Go 语言的命名是 Rob Pike 取的，因为短且易输入。早期团队中，Ken Thompson 先做了第一个编译器，后来 Ian Lance Taylor 加入，用 GCC 前端实现，这对项目推进很重要。2009 年 10 月正式发布并开源，开源日定为诞生日。


## 设计哲学

### 简单性：少即是多​​

Go 语言以“简单”为首要原则，追求语法简洁与工程友好性：

- 语法简化​​：摒弃复杂的特性（如继承、运算符重载、指针算术），通过组合和接口实现灵活性。例如，接口仅通过方法集合定义，无需显式声明实现关系。
- 工程化考量​​：选择大括号而非缩进（避免大规模代码库的缩进错误），默认零值初始化（减少内存管理负担），以及无类型常量（简化代码）。
- 二八定律​​：语言仅需支持 20% 的核心特性即可覆盖 80% 的需求，避免过度复杂化。例如，通过标准库提供高效工具（如net/http），减少重复造轮子。

### 组合与正交解耦​​

Go 语言推崇通过组合而非继承实现模块化：

- 组合哲学​​：类型通过嵌入（如结构体组合）和接口（水平组合）形成功能模块，更贴近现实世界的“物质组合”规律。例如，http.Server通过嵌入http.Handler实现功能扩展。

- 接口即契约​​：接口是隐式实现的，仅通过方法名称匹配，无需显式声明implements，降低耦合性。例如，io.Reader接口被多种类型实现。
- 正交性设计​​：语言特性相互独立且稳定，避免功能冗余。例如，goroutine与channel协同工作，但彼此无需依赖。

### 原生并发与轻量高效​​

Go 语言将并发作为“一等公民”，原生支持多核并行：

- goroutine​​：轻量级用户级线程，由运行时调度，栈空间小（初始仅 2KB），可高效创建数万个并发单元。

- channel 与 select​​：通过通信顺序控制（CSP 模型）实现同步，避免共享状态引发的锁竞争问题。例如，select语句可同时监听多个通道。
- 工程适配​​：针对云计算和分布式系统的需求，简化大规模并发编程的心智负担。例如，Docker、Kubernetes 等项目依赖 Go 的并发模型实现高可用。
​
### 面向工程，“自带电池”​​

Go 语言强调工程实践的规模化支持：

- 标准库丰富​​：提供sync（并发工具）、testing（测试框架）、log（日志管理）等高质量工具，减少依赖第三方库。

- 工具链完善​​：gofmt自动格式化代码，goimports管理依赖，go test集成测试，提升开发效率。
- 健壮性设计​​：如边界检查（数组/切片访问）、错误处理（error返回值而非异常），强制开发者关注潜在问题。

### 开放性与务实性​​

Go 语言注重透明化与实用性：

- 开源透明​​：语言实现与编译器开源，允许开发者深入理解底层机制（如垃圾回收算法）。
- 务实取舍​​：例如，放弃泛型以换取编译速度和简单性（Go 1.18 后通过type assert部分弥补），或通过iota实现枚举常量而非完整的类型系统。
- 兼容性承诺​​：Go 1 版本后严格保证向后兼容，确保生态稳定性。


## 原生编程思维来写Go代码

Go 语言的原生编程思维主要体现在其设计哲学上，核心原则包括：
- 简洁性原则​​：通过去除冗余语法和统一编码风格（如使用`gofmt`），减少开发者的复杂性负担。
- 并发原生支持​​：通过`goroutine`和`channel`提供轻量级并发编程模型，简化多线程开发。
- 接口即契约​​：接口仅通过方法集定义，无需显式实现，强调行为一致性。
- 工程化导向​​：丰富的标准库和工具链（如`net/http`、`go test`）提供现成解决方案，避免重复造轮子。
- 最小方式思维​​：鼓励开发者采用简单直接的实现方式，减少不必要的复杂性。

## 声明、类型、语句与控制结构

### 使用一致的变量声明形式

Go语言沿袭了静态编译型语言的传统：使用变量之前需要先进行变量的声明。

常见的变量声明形式：

```go
var a int32
var s string = "hello"
var i = 13
n := 17
var (
    crlf       = []byte("\r\n")
    colonSpace = []byte(": ")
)
```

Go语言有两类变量。

包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。

#### 包级变量的声明形式

1. 声明并显式初始化

包级变量只能使用带有`var`关键字的变量声明形式。

```go
var variableName = InitExpression
```

Go编译器会自动根据等号右侧的InitExpression表达式求值的类型确定左侧所声明变量的类型。

也可以显式指定类型：

```go
// 第一种
var a int32 = 17
var f float32 = 3.14

// 第二种
var a = int32(17)
var f = float32(3.14)
```

在将这些变量放在一个var块中声明时，可以采用这样的形式：

```go
var (
    a = 17
    f = float32(3.14)
)
```

2. 声明但延迟初始化

```go
var a int32
var f float64
```

没有显式初始化，但Go语言会让这些变量拥有初始的“零值”。

3. 声明聚类与就近原则

将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。这就是“声明类聚”。

变量声明最佳实践中还有一条：就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。

如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。

#### 局部变量的声明形式

1. 对于延迟初始化的局部变量声明，采用带有var关键字的声明形式

```go
// $GOROOT/src/strings/replace.go
func (r *byteReplacer) Replace(s string) string {
    var buf []byte // 延迟分配
    for i := 0; i < len(s); i++ {
        b := s[i]
        if r[b] != b {
            if buf == nil {
                buf = []byte(s)
            }
            buf[i] = r[b]
        }
    }
    if buf == nil {
        return s
    }
    return string(buf)
}
```

2. 对于声明且显式初始化的局部变量，建议使用短变量声明形式

```go
a := 17
f := 3.14
s := "hello, gopher!"
```

对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在“:=”右侧要进行显式转型：

```go
a := int32(17)
f := float32(3.14)
s := []byte("hello, gopher!")
```



